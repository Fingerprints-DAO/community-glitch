// SPDX-License-Identifier: MIT
pragma solidity 0.8.23;

interface IGlitch {
  error AddressInsufficientBalance(address account);
  error ERC721EnumerableForbiddenBatchMint();
  error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);
  error ERC721InsufficientApproval(address operator, uint256 tokenId);
  error ERC721InvalidApprover(address approver);
  error ERC721InvalidOperator(address operator);
  error ERC721InvalidOwner(address owner);
  error ERC721InvalidReceiver(address receiver);
  error ERC721InvalidSender(address sender);
  error ERC721NonexistentToken(uint256 tokenId);
  error ERC721OutOfBoundsIndex(address owner, uint256 index);
  error FailedInnerCall();
  error IdOutOfBounds();
  error InvalidPrice();
  error NotEnoughETH();
  error OnlyMinter();
  error OnlyOwner();
  error OnlyTokenOwner();
  error OwnableInvalidOwner(address owner);
  error OwnableUnauthorizedAccount(address account);
  error ReentrancyGuardReentrantCall();
  error ZeroAddress();

  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
  event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);
  event Burned(address indexed tokenOwner, uint256 indexed tokenId, uint256 indexed givenCode);
  event MetadataUpdate(uint256 _tokenId);
  event Minted(address indexed recipient, uint256 indexed tokenId);
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  event TokenRefreshed(uint256 indexed tokenId, address refresherAddress);
  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

  function adminMint(address recipient, uint256[] memory _ids) external;
  function approve(address to, uint256 tokenId) external;
  function balanceOf(address owner) external view returns (uint256);
  function burnToReedem(uint256 _tokenId, uint256 _givenCode) external;
  function fundsReceiverAddress() external view returns (address payable);
  function getAllTokensVersion() external view returns (string[] memory versions);
  function getApproved(uint256 tokenId) external view returns (address);
  function getTokenVersion(uint256 tokenId) external view returns (string memory versionStr);
  function getTokensByOwner(address _owner) external view returns (uint256[] memory tokenIds);
  function isApprovedForAll(address owner, address operator) external view returns (bool);
  function mint(address recipient, uint256 _id) external;
  function minterContractAddress() external view returns (address);
  function name() external view returns (string memory);
  function owner() external view returns (address);
  function ownerOf(uint256 tokenId) external view returns (address);
  function refreshToken(uint256 _tokenId) external payable;
  function refreshTokenPrice() external view returns (uint256);
  function renounceOwnership() external;
  function safeTransferFrom(address from, address to, uint256 tokenId) external;
  function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) external;
  function setApprovalForAll(address operator, bool approved) external;
  function setBaseURI(string memory newBaseURI) external;
  function setFundsReceiverAddress(address newFundsReceiverAddress) external;
  function setMinterContractAddress(address newMinterContractAddress) external;
  function setRefreshTokenPrice(uint256 newRefreshTokenPriceInWei) external;
  function supportsInterface(bytes4 interfaceId) external view returns (bool);
  function symbol() external view returns (string memory);
  function tokenByIndex(uint256 index) external view returns (uint256);
  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);
  function tokenURI(uint256 tokenId) external view returns (string memory);
  function totalSupply() external view returns (uint256);
  function transferFrom(address from, address to, uint256 tokenId) external;
  function transferOwnership(address newOwner) external;
}
